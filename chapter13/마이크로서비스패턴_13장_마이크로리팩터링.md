마이크로 서비스 패턴 
	13장 마이크로서비스로 리팩터링
		https://microservices.io/patterns/refactoring/strangler-application.html
			그림 13-1.png
			
	13.1 마이크로서비스 리팩터링 개요
		13.1.1 모놀리스를 왜 리팩터링 하는가?
			Monolith지옥
				느린전달: 이해, 관리, 테스트가 어려워 생산성 저하
				버그 투성이 소프트웨어 릴리스: 테스트성 결여
				나쁜 확장성: 리소스 요건이 다른 컴포넌트 조합이 힘듬

		13.1.2 모놀리스 옥죄기
			완전히 뜯어고치기를 삼가하라 -> 리스크가 너무 큼
			단계적 리팩터링, Strangler(옥죄는 것) Application
			값을 조기에 자주 검증
				단계적 리팩터링 -> 가치 전달(공통/알고리즘 개발/배포) -> 아키텍처 전환  
				* 기술 부채: 과거 접근하기 쉬운 제한된 솔루션을 채택하여 추가적인 재작업의 비용이 커짐
			모놀리스 변경 최소화
			기술 배포 인프라: 모든것이 다 필요한 것은 아니다
				테스트 자동화 배포 파이프라인을 제외하고 서비스를 돌려보며 기술 경험 후 의사결정
			
	13.2 모놀리스 -> 마이크로서비스 리팩터링 전략
		1. 새 기능을 서비스로 구현
		2. 표현 계층과 벡엔드 분리
		3. 기능을 여러 서비스로 추출해서 모놀리스를 분해
		
		13.2.1 새 기능을 서비스로 구현한다.
			구멍의 법칙: "구멍에 빠졌다는 것을 알았으면 땅은 그만파라" -> 비대해지고 관리하기 어려운 모놀리스를 더 키우지 마라
			
			새 서비스를 모놀리스에 연계
				API 게이트웨이: 새 기능의 요청은 새 서비스로, 기존 요청은 모놀리스로 각각 라우팅
				통합 글루 코드: 서비스가 모놀리스 데이터에 접근하고 모놀리스에 구현된 기능을 호출할 수 있게 서비스를 모놀리스에 통합
			새 기능을 서비스로 구현하는 시점
				기존 모놀리스에 단단히 결집되어 있는 기능을 무리하게 서비스로 추출 -> 과도한 IPC, 데이터 일관성 결여
				모놀리스 수평적 쪼개기
			그림 13-2.jpg
			
		13.2.2 표현 계층과 벡엔드를 분리한다
			표현 계층: HTTP 요청을 처리해서 웹 UI에 전달할 HTML 페이지를 생성하는 모듈로 구성, 사용자 인터페이스가 정교한 어플리케이션은 표현 계층이 코드 대부분을 차지
			비즈니스 로직: 엔터프라이즈 애플리케이션 특성상 복잡한 비즈니스 규칙이 구현된 모듈로 구성
			데이터 접근 로직: DB, 메시지 브로커등 인프라 서비스에 접근하는 모듈로 구성
			
			Layer를 나눈 후 원격 호출 이점
				1. 독립적 개발/배포
				2. 나중에 개발할 마이크로서비스가 호출할 수 있는 원격 API가 표출
			그림 13-3.jpg
			
		12.2.3 기능을 여러 서비스로 추출한다
			모놀리스를 서비스로 추출해야할 기능
				* API 끝점이 구현된 인바운드 어댑터
				* 도메인 로직
				* DB 접근 로직 등이 구현된 아웃바운드 어댑터
				* 모놀리스의 DB 스키마
				추출의 대가가 많기 때문에 중요하고 계속 발전하는 서비스를 추출하는 것이 좋다.
			
			도메인 모델 분리
				서비스 경계를 넘나드는 객체 레퍼런스 솎아내기 Ex)지속적 클래스 참조, Object 주입
				-> DDD 애그리거트 참조방법인 기본키로 객체 참조
			DB 리팩터링
				도메인 모델은 DB스키마에 매핑되어 있으므로 테이블도 분리해서 서비스로 이전 필요 -> 리팩터링 데이터베이스(위키북스, 2007) -> DB 스키마 리팩터링 전략
				데이터를 복제해서 DB 클라이언트가 새 스키마를 사용하도록 단계적 업데이트
			변경 범위를 줄이기 위해 데이터를 복제
			
			어떤 서비스를 언제 추출하나
				시간별로 구획된 아키텍처 정의 
					1. 요건이 있을떄 마다 서비스 추출
					2. APP 모듈별 기대 혜택 순위 매김
						* 개발 가속화
						* 성능, 확장성, 신뢰성 문제 해결
						* 다른 서비스로 추출할 수 있게 만듬: 모듈간 디펜던시 끊음
			그림 13-4.jpg
			그림 13-7.jpg
			
	13.3 서비스와 모놀리스 간 협동 설계
		데이터 일관성 유지 필수 -> 고려사항: ACID(원자성, 일관성, 고립성, 지속성) 트랜잭션에 묶여 있던 코드도 함께 분리 -> 사가 사용
		
		13.3.1 통합 글루 설계
			통합 글루 API 설계
				도메인 로직에 어떤 API를 제공할지 결정
				IPC를 인터페이스로 캡슐화 
			상호 작용 스타일과 IPC 선택
				리포지터리 인터페이스를 구현한 어댑터로 데이터 프로바이더의 API를 호출
				단, 조회는 요청 개수가 많아지면 효율이 떨어지므로 데이터 컨슈머가 데이터 레플리카(CQRS뷰)를 유지
					-> 도메인 이벤트를 구곧해서 레플리카를 항상 최신 상태로 유지
					-> 이벤추에이트 트램 같은 프레임워크에 구현된 트랜잭셔널 메시징 통신으로 양쪽 모두 업데이트 가능
			부패-방지 계층(Anti-Corruption Layer) 구현
				상이한 두 도메인 모델이 서로 상대편을 더럽히지 않도록 변환해주는 소프트웨어 계층
				서로 다른 두 도메인 도델간의 변환 담당
					이벤트 핸들러
					변환 계층
					메시징 클라이언트 
			모놀리스가 도메인 이벤트를 발행/구독하는 방법
				1. 서비스가 사용하는 것과 동일한 이벤트 발행 장치를 적용 -> 모놀리스는 이벤트 발행 자체가 불가한 경우(저장 프로시저)가 많다.
				2. DB 수준에서 도메인 이벤트 발행 -> 테이블 변경사항 나타내는 수준
				메시지 브로커 클라이언트를 지원하지 않는 언어인 경우 헬퍼 어플리케이션으로 DB 직접 업데이트
			그림13-9.jpg
			그림13-10.jpg
			그림13-11.jpg
			그림13-12.jpg
			
		13.3.2 서비스와 모놀리스에 걸쳐 데이터 일관성 유지
			* 사가: 비동기 메시징을 통행 편성되는 일련의 로컬 트랜잭션
			* 보상 트랜잭션: 로컬 트랜잭션이 업데이트한 내용을 언두하는 트랜잭션
			* 대책: 사가간 비격리 문제를 해결하는데 사용되는 대체 설계 기법
			* 시멘틱 락: 사가에 의해 업데이트되는 레코드에 플래그를 세팅하는 정책
			* 보상 가능 트랜잭션: 사가의 후속 트랜잭셩 중 하나가 실패할 가능성이 있어 보상 트랜잭션이 필요한 트랜잭션
			* 피봇 트랜잭션: 사가의 진행/중단 지점에 위치한 트랜잭션. 피봇 트랜잭션이 성공하면 사가는 완료할 때까지 실행
			* 재시도 가능 트랜잭션: 피봇 트랜잭션 다음에 나오는 트랜잭션으로 반드시 성공
			
			보상 트랜잭션을 지원하도록 모놀리스를 고치기는 어렵다
			사가 적용시 모놀리스는 보상 트랜잭션을 지원할 필요가 없다
			서비스 추출 순서를 조정하면 보상 트랜잭션을 모놀리스에 구현하지 않아도 된다
		
		13.3.3 인증/ 인가 처리
			그림 13-13.jpg
			인-메모리 세션기반
			모놀리스의 LoginHandler는 USERINFO 쿠키를 세팅한다
			API 게이트웨이는 USERINFO 쿠키를 Authorization헤더에 매핑한다
				
	13.4 새기능을 서비스로 구현: 배달 실패한 주문 처리
		13.4.1 배달지연 서비스 설계
		13.4.2 배달 지연 서비스를 위한 통합 글루 설계
	13.5 모놀리스 분해
		13.5.1 현행 배달 관리 기능
		13.5.2 배달 서비스 개요
		13.5.3 배달 서비스 도메인 모델 설계
		13.5.4 배달 서비스의 통합 글루 설계
		13.5.5 배달 서비스의 상화 작용할 수 있게 모놀리스를 변경
		 * 피처 토글: 코드 변경 분을 사용자에게 릴리스 않고 도 배포-> 마틴 파울러 https://martinfowler.com/articles/feature-toggles.html
	13.6 마치며

		
